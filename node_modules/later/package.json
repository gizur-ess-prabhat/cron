{
  "name": "later",
  "version": "0.0.19",
  "description": "Determine later (or previous) occurrences of recurring schedules",
  "keywords": [
    "schedule",
    "occurrences",
    "recur",
    "cron"
  ],
  "author": {
    "name": "BunKat",
    "email": "bill@bunkat.com"
  },
  "main": "./app",
  "repository": {
    "type": "git",
    "url": "git://github.com/bunkat/later.git"
  },
  "bugs": {
    "url": "http://github.com/bunkat/later/issues"
  },
  "engines": {
    "node": ">= 0.4.0"
  },
  "scripts": {
    "test": "make test",
    "build": "make build"
  },
  "devDependencies": {
    "mocha": "*",
    "should": ">=0.6.3",
    "jslint": "*",
    "uglify-js": "*"
  },
  "readme": "_Later_ is a simple library for describing recurring schedules and calculating their future occurrences.  It supports a very flexible schedule definition including support for composite schedules and schedule exceptions.  _Later_ also supports executing a callback on a provided schedule. \n\nThere are four ways that schedules can be defined: using the chainable _Recur_ api, using an English expression, using a Cron expression, or they can also be manually defined. _Later_ works in both the browser and [node](http://nodejs.org) and the core engine for calculating schedules is only 1.3k minified and compressed.\n\n## Primary Goal\n\nThe primary goal of _Later_ is to produce deterministic schedules. These are schedules that can be calculated at any time and will always produce the same results provided the same start time. This is important because it means that the schedule can be stored and instances dynamically calculated as needed instead of having to store previous instances to calculate future occurrences.\n\nFor example, a schedule such as `every 10 mins on Friday` is deterministic. A schedule such as `after 5 mins` is not deterministic. You would have to know the previous occurrence to figure out the next occurrence. While these types of schedules are supported, it is not the primary focus of _Later_. \n\nExample uses of _Later_ schedules:\n* Run a report on the last day of every month at 12 AM except in December\n* Install patches on the 2nd Tuesday of every month at 4 AM\n* Gather CPU metrics every 10 mins Mon - Fri and every 30 mins Sat - Sun\n* Send out a scary e-mail at 13:13:13 every Friday the 13th\n\nSchedules that _Later_ supports but for which it is probably overkill:\n* Run a task after 5 minutes from the start time \n\n## Node Example\n\n```js\nvar recur = require('later').recur\n  , cron = require('later').cronParser\n  , text = require('later').enParser\n  , later = require('later').later\n  , rSched, cSched, tSched, mSched, aSched, results;\n\n// equivalent schedules for every 5 minutes on the hour\nrSched = recur().every(5).minute();\ncSched = cron().parse('* */5 * * * *', true);\ntSched = text().parse('every 5 minutes');\nmSched = {schedules: [ {m: [0,5,10,15,20,25,30,35,40,45,50,55]}]};\n\n// schedule for every 5 minutes from the start time\naSched = text().parse('after 5 minutes');\naSched = recur().after(5).minute();\n\n// calculate the next occurrence, using a minimum resolution of 60 seconds\n// otherwise every second of every minute would be valid occurrences\nresults = later(60).getNext(rSched);\n\n// calculates the next 10 occurrences starting on Jan 1st 2013\nresults = later(60).get(rSched, 10, new Date('1/1/2013'));\n\n// executes fn every 5 minutes\nvar fn = function() {\n  console.log(new Date().toLocaleString());\n}\nvar l = later(60);\nl.exec(cSched, (new Date()), fn);\n\n// stops execution\nl.stopExec();\n```\n\n## Browser Example\n\n    <script src=\"later.min.js\" type=\"text/javascript\"></script>\n    <script type=\"text/javascript\">\n\n    // create the desired schedule\n    var schedule = enParser().parse('every 5 minutes');\n\n    // calculate the next 5 occurrences with a minimum resolution of 60 seconds, using local time\n    var results = later(60, true).get(schedule, 5);\n\n    </script>\n\n## Installation\n\nUsing npm:\n\n    $ npm install later\n\nUsing bower:\n\n    $ bower install later\n\n## Important: A note about underspecified schedules\n\n_Later_ works as a very primitive constraints solver.  A _Later_ schedule is simply a set of constraints indicating the valid values for a set of time periods.  _Later_ then finds the date and time (or any number of occurrences) that meets all of the constraints. \n\nThis has the side effect that _Later_ assumes that all time periods are valid unless specific valid values have been indicated. In other words, if no value for `seconds` is specified then _Later_ will assume that any value for `seconds` is valid (in reality, it won't even bother looking at the `seconds` value).  This can be confusing when you are looking at occurrences generated by _Later_.\n\nFor example:\n\n    rSched = recur().every(5).minute();\n    later().get(rSched, 5, new Date('2012-01-31T10:04:00Z'));\n\n    2012-01-31T10:05:00Z\n    2012-01-31T10:05:01Z\n    2012-01-31T10:05:02Z\n    2012-01-31T10:05:03Z\n    2012-01-31T10:05:04Z\n\nProbably not what you were expecting! This happened becase the schedule was _underspecified_. You probably meant to specify a schedule that occured once every five minutes, but you actually specified a schedule that means _check that the minutes value is divisible by 5_.  Since the resolution (or minimum time between valid occurrences) is set to 1 second by default, _Later_ kept bumping the previous value by 1 second and checking against the constraints.  Since they were all met, the occurrence was considered valid.\n\n##### Fixing underspecified schedules\n\nThere are two fixes for underspecified schedules.  First, modify the schedule resolution to a higher value such that occurrences happen at the desired frequency. In this case, we bump the resolution up to 60 seconds to ensure that valid occurrences are at least 1 minute apart.\n\n    rSched = recur().every(5).minute();\n    later(60).get(rSched, 5, new Date('2012-01-31T10:05:13Z'));\n\n    2012-01-31T10:05:13Z\n    2012-01-31T10:10:00Z\n    2012-01-31T10:15:00Z\n    2012-01-31T10:20:00Z\n    2012-01-31T10:25:00Z\n\nNote that the schedule will now occur at most once every five minutes as desired. However, keep in mind that every second is considered valid and so the first occurrence will depend on your start time. The other fix is to fully specify the schedule.\n\n    rSched = recur().every(5).minute().on(0).second();\n    later().get(rSched, 5, new Date('2012-01-31T10:05:13Z'));\n\n    2012-01-31T10:10:00Z\n    2012-01-31T10:15:00Z\n    2012-01-31T10:20:00Z\n    2012-01-31T10:25:00Z\n    2012-01-31T10:30:00Z\n\nNow every occurrence will occur on minutes divisible by 5 and when seconds is 0. This is probably closer to what you expected.\n\n## Time Periods\n\n_Later_ supports constraints using following time periods (Note: Not all of these are supported when using Cron expressions):\n\n#### Seconds (s)\n\nDenotes seconds within each minute.  \nMinimum value is 0, maximum value is 59. Specify 59 for last.  \n\n#### Minutes (m)\n\nDenotes minutes within each hour.  \nMinimum value is 0, maximum value is 59. Specify 59 for last.  \n\n#### Hours (h)\n\nDenotes hours within each day.  \nMinimum value is 0, maximum value is 23. Specify 23 for last.  \n\n#### Days Of Month (D)\n\nDenotes number of days within a month.  \nMinimum value is 1, maximum value is 31.  Specify 0 for last.  \n\n#### Days Of Week (dw)\n\nDenotes the days within a week.  \nMinimum value is 1, maximum value is 7.  Specify 0 for last.\n    \n    1 - Sunday\n    2 - Monday\n    3 - Tuesday\n    4 - Wednesday\n    5 - Thursday\n    6 - Friday\n    7 - Saturday  \n\n#### Day of Week Count (dc)\n\nDenotes the number of times a particular day has occurred within a month.  Used to specify things like second Tuesday, or third Friday in a month.  \nMinimum value is 1, maximum value is 5.  Specify 0 for last.\n    \n    1 - First occurrence\n    2 - Second occurrence\n    3 - Third occurrence\n    4 - Fourth occurrence\n    5 - Fifth occurrence\n    0 - Last occurrence  \n\n#### Day of Year (dy)\n\nDenotes number of days within a year.  \nMinimum value is 1, maximum value is 366.  Specify 0 for last.  \n\n#### Week of Month (wm)\n\nDenotes number of weeks within a month. The first week is the week that includes the 1st of the month. Subsequent weeks start on Sunday.     \nMinimum value is 1, maximum value is 5.  Specify 0 for last.  \n\nFor example, February of 2012:\n\n    Week 1 - February 2nd,  2012\n    Week 2 - February 5th,  2012\n    Week 3 - February 12th, 2012 \n    Week 4 - February 19th, 2012 \n    Week 5 - February 26th, 2012\n\n#### Week of Year (wy)\n\nDenotes the ISO 8601 week date. For more information see: [http://en.wikipedia.org/wiki/ISO_week_date](http://en.wikipedia.org/wiki/ISO_week_date).  \nMinimum value is 1, maximum value is 53.  Specify 0 for last.\n\n#### Month of Year (M)\n\nDenotes the months within a year.  \nMinimum value is 1, maximum value is 12.  Specify 0 for last.\n\n    1 - January\n    2 - February\n    3 - March\n    4 - April\n    5 - May\n    6 - June\n    7 - July\n    8 - August\n    9 - September\n    10 - October\n    11 - November\n    12 - December  \n\n#### Year (Y)\n\nDenotes the four digit year.  \nMinimum value is 1970, maximum value is 2450 (arbitrary).  \n\n## After constraints\n\nOther than Cron expressions, all other types of schedules support after constraints.  Use after constraints when you want a schedule to first occur after a certain amount of time instead of at a specific date and time.  For example to specify a schedule that continually occurs after 5 minutes:\n\n   var s = enParser().parse('after 5 mins');\n\n\nAfter constraints can be chained together with the resultant after constraint being the sum of all of the constraints.  For example, to specify a schedule that occurs after 1 day and 15 minutes:\n\n    var s = recur().after(1).dayOfYear().after(2).minute();\n\nThe first valid occurrence will be 24 hours and 2 minutes from the start date.\n\n## Composite Schedules\n\nOther than Cron expressions, all other types of schedules support composite schedules.  A composite schedule can include multiple sets of constraints.  An occurrence is considered valid if it meets all of the constraints within any one set of the constraints defined.\n\n    var s = enParser().parse('every 5 mins also at 11:07 am');\n\nThis schedule will produce occurrences on the five minute boundaries (11:00 am, 11:05 am, etc) but will also have a valid occurrence at 11:07 am.\n\n## Schedule Exceptions\n\nOther than Cron expressions, all other types of schedules support exception schedules (which can be composite shedules).  An occurrence is considered invalid if it meets all of the constraints within any exception schedule that has been defined.\n\n    var s = recur().every(1).hour().except().onWeekends().and().at('13:00:00');\n\nThis schedule will produce occurrences on the hour (make sure to set the minimum resolution when calculating schedules to 3600 seconds or every second of every minute would also be valid).  No valid occurrences will ever occur on weekends or at 1:00 pm.\n\n## Creating Schedules using Recur\n\n_Recur_ provides a simple, chainable API for creating schedules.  All valid schedules can be produced using this API. See the example folder and the test folder for lots of examples of valid schedules.\n\n#### Time periods\n\nRecur uses the following:\n\n    second();\n    minute();\n    hour();\n    dayOfWeek();\n    dayOfWeekCount();\n    dayOfMonth();\n    dayOfYear();\n    weekOfMonth();\n    weekOfYear();\n    month();\n    year();\n\n#### on(_args_)\n\nSpecifies one or more specific occurrences of a time period.\n\n    recur().on(2).minute();\n    recur().on(4,6).dayOfWeek();\n\n#### onWeekend()\n\nShorthand for `on(1,7).dayOfWeek()`.\n\n#### onWeekday()\n\nShorthand for `on(2,3,4,5,6).dayOfWeek()`.\n\n#### every(x)\n\nSpecifies an interval `x` of occurrences of a time period.  By default, intervals start at the minimum value of the time period and go until the maximum value of the time period. \n\nFor example:\n\n    recur().every(2).month();\n\nWill include months 1,3,5,7,9,11.\n\n#### after(x)\n\nSpecifies the minimum interval `x` of a time period that must pass between valid instances of the schedule.  \n\nFor example:\n\n    recur().after(2).month();\n\nWill cause the first valid occurrence to be two months after the start date.\n\n#### startingOn(x)\n\nSpecifies the starting occurrence `x` of a time period.  Must be chained after an `every` call.\n\n    recur().every(4).weeksOfYear().startingOn(2);\n\n#### between(x, y)\n\nSpecifies the starting occurrence `x` and ending occurrence `y` of a time period.  Must be chained after an `every` call.\n\n    recur().every(6).dayOfYear().between(10,200);\n\n#### at(time)\n\nSpecifies a specific time for the schedule.  The time must be in 24 hour time and time zone agnostic.\n\n    recur().at('11:00:00');\n\n#### and()\n\nCreates a composite schedule.\n\n    recur().every(2).hour().onWeekend().and().every(5).minute().every(2).hour().onWeekday();\n\n### except()\n\nCreates an exception schedule.\n\n    recur().every(2).hour().except().onWeekday().and().on(25).dayOfMonth().on(12).month();\n\n\n## Creating Schedules using Text Expression\n\nSchedules can also be created using an English text expression syntax.  All valid schedules can be produced in this manner.  See the example folder and the test folder for lots of examples of valid schedules.\n\n    var s = enParser().parse('every 5 minutes');\n\nIf the text expression could not be parsed, `s.error` will contain the position in the string where parsing failed or -1 if no errors were found.\n\n#### _timePeriod_\n\nThe valid time period expressions are:\n\n* (s|sec(ond)?(s)?),  \n* (m|min(ute)?(s)?),  \n* (h|hour(s)?),  \n* (day(s)?( of the month)?),  \n* day instance,  \n* day(s)? of the week,  \n* day(s)? of the year,  \n* week(s)?( of the year)?,  \n* week(s)? of the month,  \n* month(s)?,  \n* year  \n\n#### _num_\n\n((\\d\\d\\d\\d)|([2-5]?1(st)?|[2-5]?2(nd)?|[2-5]?3(rd)?|(0|[1-5]?[4-9]|[1-5]0|1[1-3])(th)?))\n\n#### _time_\n\n((([0]?[1-9]|1[0-2]):[0-5]\\d(\\s)?(am|pm))|(([0]?\\d|1\\d|2[0-3]):[0-5]\\d)),\n\n#### _monthName_\n\n(jan(uary)?|feb(ruary)?|ma((r(ch)?)?|y)|apr(il)?|ju(ly|ne)|aug(ust)?|oct(ober)?|(sept|nov|dec)(ember)?)\n\n#### _dayName_\n\n((sun|mon|tue(s)?|wed(nes)?|thu(r(s)?)?|fri|sat(ur)?)(day)?)\n\n#### _numRange_ \n\n_num_((-|through)_num_)?((,|and)_numRange)\\*\n\n#### _monthRange_ \n\n_monthName_((-|through)_monthName_)?((,|and)_monthName_)\\*\n\n#### _dayRange_ \n\n_dayName_((-|through)_dayName_)?((,|and)_dayName_)\\*\n\n#### _specificTime_\n\non the ( first | last | _numRange_ _timePeriod_ )\n\n#### _startingOn_\n\n(start(ing)? (at|on( the)?)?) _num_ _timePeriod_\n\n#### _between_\n\nbetween (the)? _num_ and _num_\n\n#### _recurringTime_\n\nevery ( weekend | weekday | _num_ _timePeriod_ ( _startingOn_ | _between_ ))\n\n#### _after_\n\nafter _num_ _timePeriod_\n\n#### _onDayOfWeek_\n\non _dayRange_\n\n#### _ofMonth_\n\nof _monthRange_\n\n#### _inYear_\n\nin _numRange_\n\n#### _schedule_\n\n( _specificTime_ | _recurringTime_ | _after_ | _onDayOfWeek_ | _ofMonth_ | _inYear_ )\\*\n\n#### _compositeSchedule_\n\n( _schedule_ )( also _schedule_ )\\*( except )( _schedule_ )( also _schedule_ )\\*\n\n## Creating Schedules using Cron\n\nA valid schedule can be generated from any valid Cron expression. For more information on the Cron expression format, see: [http://en.wikipedia.org/wiki/Cron](http://en.wikipedia.org/wiki/Cron).  Currently Cron expressions are the most compact way to describe a schedule, but are slightly less flexible (no direct support for composite or exception schedules) and can be harder to read.\n\n#### parse(expr [,_hasSeconds_])\n\nParses the Cron expression `expr` and returns a valid schedule that can be used with _Later_.  If `expr` contains the seconds component (optionally appears before the minutes component), then `hasSeconds` must be set to true.\n\n    var s = cronParser().parse('* */5 * * * *', true);\n\n## Creating Schedules Manually\n\nSchedules are basic `json` objects that can be constructed directly if desired. The schedule object has the following form:\n\n```js\n{\n  schedules: [\n    {\n      // constraints\n    },\n    {\n      // constraints\n    },\n\n  ],\n  exceptions: [\n    {\n      // constraints\n    },\n    {\n      // constraints\n    },\n  ]\n}\n```\n\nwhere `constraints` are of the form:\n\n```js\nconstraint_id: [\n  //valid values\n],\n```\n\nThe `constraint_id`s can be found in the _Time Periods_ section above following the constraint name along with the valid values.  To specify an after constraint, prefix the desired constraint_id with `a`.\n\nFor example, the schedule _every hour on weekdays and every other hour on weekends_ would be defined as:\n\n```js\n{schedules: [ \n  {\n    h: [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23], \n    d: [2,3,4,5,6]\n  },\n  {\n    h: [0,2,4,6,8,10,12,14,16,18,20,22], \n    d: [1,7]}\n  ]\n};\n```\n\n## Calculating Occurrences\n\n#### later(_[resolution[, useLocalTime]]_)\n\nConfigures _later_ to calculate future occurrences. `Resolution` is the minimum amount of time in seconds between valid occurrences. The default is 1 second which may produce undesirable results when calcuating multiple occurrences into the future. \n\nTo calculate occurrences for a schedule that occurs every five minutes, either of the following would produce the expected results:\n\n    var s = recur().every(5).minute();\n    var r = later(60).get(s,10);\n\n    var s = recur().every(5).minute().first().second();\n    var r = later().get(s,10);\n\nBy default, all schedules are calculated using UTC time. Set `useLocalTime` to true to do calculations using local time instead. This makes hour, minute, and time constraints fall on the expected values on a local machine.  Schedule definitions are always time zone agnostic. \n\n#### getNext(recur, _[startDate[, endDate]]_)\n\nReturns the next valid occurrence of the schedule definition, `recur`, that is passed in or null if no occurrences exist. Pass in `Date` objects to `startDate` and `endDate` to define the time range to find the next valid occurrence.  By default `startDate` is the current date and time and there is no `endDate`.\n\n    var s = cronParser().parse(* */5 * * * *);\n    later().getNext(s, new Date('1/1/2012'), new Date('1/1/2013'));\n\n#### getPrevious(recur, _[startDate[, endDate]]_)\n\nReturns the previous valid occurrence of the schedule definition, `recur`, that is passed in or null if no occurrences exist. Pass in `Date` objects to `startDate` and `endDate` to define the time range to find the next valid occurrence.  For previous occurrences, the `startDate` must be greater than the `endDate`. By default `startDate` is the current date and time and there is no `endDate`.\n\n    var s = cronParser().parse(* */5 * * * *);\n    later().getPrevious(s, new Date('1/1/2013'), new Date('1/1/2012'));\n\n#### get(recur, count, _[startDate[, endDate][, reverse]]_)\n\nReturns the next `count` occurrences of the schedule definition, `recur`, that is passed in or null if no occurrences exist. Pass in `Date` objects to `startDate` and `endDate` to define the time range to find the next valid occurrences.  By default `startDate` is the current date and time and there is no `endDate`. Setting `reverse` to true will return the previous occurrences starting from `startDate` and working backwards. \n\n    var s = cronParser().parse(* */5 * * * *);\n    later().get(sched, 10, new Date('1/1/2012'), new Date('1/1/2013'));\n\n#### isValid(recur, date)\n\nReturns true if `date` is a valid occurrence of the schedule defined by `recur`.\n\n#### exec(recur, startDate, callback, arg)\n\nExecutes `callback` on the schedule defined by `recur` starting on `startDate`. The callback will be called with whatever is passed in as `arg`. The callback will continue to be called until either `stopExec` is called or there are no more valid occurrences of the schedule.  Only one schedule should be executed per `later` object to make stoping execution simpler.\n\nDo this:\n\n```js\nvar s1 = cronParser().parse('* */5 * * * *');  \nvar every5 = later();  \never5.exec(s1, new Date(), cb);    \n\nvar s2 = cronParser().parse('* */6 * * * *');\nvar every6 = later();\nevery6.exec(s2, new Date(), cb);\n```\n\nNot this:\n\n```js\nvar s1 = cronParser().parse('* */5 * * * *');\nvar s2 = cronParser().parse('* */6 * * * *');\nvar l = later();\nl.exec(s1, new Date(), cb);  \nl.exec(s2, new Date(), cb);\n```\n\n#### stopExec()\n\nImmediately stops the execution of any schedule execution created using `exec`.\n\n## Building\n\nTo build the minified javascript files for _later_:\n\n    $ make build\n\nThere are 5 different javascript files that are built.\n\n* __later.min.js__ contains all of the library files\n* __later-core.min.js__ contains only the core engine for calculating occurrences\n* __later-recur.min.js__ contains only the files needed to use Recur based scheduling\n* __later-cron.min.js__ contains only the files needed to use Cron based scheduling\n* __later-en.min.js__ contains only the files need to use English text based scheduling\n\n## Running tests\n\nTo run the tests for _later_, run `npm install` to install dependencies and then:\n\n    $ make test\n\n## Performance\n\nSome basic performance tests are available on __jsperf__:\n\n* [Schedule Definition](http://jsperf.com/later-schedule-def)\n* [Recurrence Calculation](http://jsperf.com/later-schedule-calc)\n\n## License \n\n(The MIT License)\n\nCopyright (c) 2011 BunKat LLC &lt;bill@bunkat.com&gt;\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n'Software'), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WIT",
  "readmeFilename": "Readme.md",
  "_id": "later@0.0.19",
  "dist": {
    "shasum": "3870b914d27b1224eb60d295b1bc16f5ea6e5398"
  },
  "_from": "later@>=0",
  "_resolved": "https://registry.npmjs.org/later/-/later-0.0.19.tgz"
}
